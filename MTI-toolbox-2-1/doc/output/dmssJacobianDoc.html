<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>jacobian</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-06-24">
<meta name="DC.source" content="dmssJacobianDoc.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>jacobian</h1>
<!--introduction-->
<p>Calculate jacobian matrix of a dmss model.</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Syntax</a>
</li>
<li>
<a href="#2">Description</a>
</li>
<li>
<a href="#3">Examples</a>
</li>
<li>
<a href="#12">References</a>
</li>
<li>
<a href="#13">See also</a>
</li>
</ul>
</div>
<h2 id="1">Syntax</h2>
<p>J = jacobian(sys) Calculate jacobian matrix with default symbolic variables [xpi, xi, ui, yi].</p>
<p>J = jacobian(sys, xp, x, u, y) Calculate jacobian matrix for given variable values (numeric or symbolic).</p>
<p>J = jacobian(sys, xp, x, u, y, z) Calculate jacobian matrix for given variable values (numeric or symbolic) for hybrid dmss model (Experimental).</p>
<h2 id="2">Description</h2>
<p>jacobian(sys) calculates the jacobian matrix of an implicit multilinear time-invariant (iMTI) model stored as dmss object based of the decomposed parameter tensor sys.H (based of its structure matrix sys.H.F and parameter matrix sys.H.phi) with numeric or smybolic parameters, using similar principles as in [1] for explicit mutlilinear time invariant (eMTI) models.</p>
<h2 id="3">Examples</h2>
<p>The following equations describe a simple HVAC system</p>
<pre class="codeinput">Eq =                            [<span class="string">"m*xp1 - y4 - y2 = 0"</span>;<span class="keyword">...</span>
                                      <span class="string">"m*xp2 - y3 = 0"</span>;<span class="keyword">...</span>
                 <span class="string">"x1 - c_d*y1 - r0*x2 - c_v*x2*y1 = 0"</span>;<span class="keyword">...</span>
<span class="string">"y2 + u1*x1 - c_d*u1*u2 - r0*u1*u3 - c_v*u1*u2*u3 = 0"</span>;<span class="keyword">...</span>
                              <span class="string">"y3 - u1*u3 + u1*x2 = 0"</span>;<span class="keyword">...</span>
                            <span class="string">"y4 + A*k*u4 - A*k*y1 = 0"</span>];
</pre>
<p>which can be converted into a continuous-time dmss model by</p>
<pre class="codeinput">sys = sym2dmss(Eq, 0);
</pre>
<pre class="codeoutput">Reduced by 5 column(s) and 0 equation(s) with trivial Reduction due to duplications.
</pre>
<p>and serves as an example system.</p>
<p>
<b>Calculate symbolic jacobian matrix:</b>
</p>
<p>The symbolic jacobian matrix can be calculated simply by</p>
<pre class="codeinput">J = sys.jacobian()
</pre>
<pre class="codeoutput">
J = 

  struct with fields:

      equality: [1&times;1 struct]
    inequality: [1&times;1 struct]

</pre>
<p>For viewing the entries of the jacobian matrix the entries of the struct can be accessed.</p>
<pre class="codeinput">disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))
</pre>
<pre class="codeoutput">[m, 0,  0,             0,              0, -1,  0, -1,                               0,                    0,                   0,   0]
[0, m,  0,             0,              0,  0, -1,  0,                               0,                    0,                   0,   0]
[0, 0,  1, - r0 - c_v*y1, - c_d - c_v*x2,  0,  0,  0,                               0,                    0,                   0,   0]
[0, 0, u1,             0,              0,  1,  0,  0, x1 - c_d*u2 - r0*u3 - c_v*u2*u3, - c_d*u1 - c_v*u1*u3, - r0*u1 - c_v*u1*u2,   0]
[0, 0,  0,            u1,              0,  0,  1,  0,                         x2 - u3,                    0,                 -u1,   0]
[0, 0,  0,             0,           -A*k,  0,  0,  1,                               0,                    0,                   0, A*k]
 
</pre>
<p>where the rows correspond to the six equations and the columns to the variables (2 state derivatives, 2 states, 4 inputs, 4 algebraic variables).</p>
<p>
<b>Calculate symbolic jacobian matrix using nondefault variable symbols:</b>
</p>
<p>Nondefault variable symbols can be used by using the additional inputs of jacobian()</p>
<pre class="codeinput">dx = sym(<span class="string">'dx'</span>,[sys.n,1]);
x = sym(<span class="string">'x'</span>,[sys.n,1]);
in = sym(<span class="string">'in'</span>,[sys.m,1]);
out = sym(<span class="string">'out'</span>, [sys.p,1]);

J = sys.jacobian(dx, x, in, out);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))
</pre>
<pre class="codeoutput">[m, 0,   0,               0,              0, -1,  0, -1,                                   0,                       0,                      0,   0]
[0, m,   0,               0,              0,  0, -1,  0,                                   0,                       0,                      0,   0]
[0, 0,   1, - r0 - c_v*out1, - c_d - c_v*x2,  0,  0,  0,                                   0,                       0,                      0,   0]
[0, 0, in1,               0,              0,  1,  0,  0, x1 - c_d*in2 - in3*r0 - c_v*in2*in3, - c_d*in1 - c_v*in1*in3, - in1*r0 - c_v*in1*in2,   0]
[0, 0,   0,             in1,              0,  0,  1,  0,                            x2 - in3,                       0,                   -in1,   0]
[0, 0,   0,               0,           -A*k,  0,  0,  1,                                   0,                       0,                      0, A*k]
 
</pre>
<p>
<b>Calculate jacobian matrix using numeric variable values:</b>
</p>
<p>For calculating the jacobian matrix for certain numeric variable values, they can be simply entered as the inputs of jacobian()</p>
<pre class="codeinput">dx = zeros(sys.n, 1);
x = zeros(sys.n, 1);
u = zeros(sys.m, 1);
y = zeros(sys.p, 1);

J = sys.jacobian(dx, x, u, y);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))
</pre>
<pre class="codeoutput">[m, 0, 0,   0, 0, 0, 0,   0,    0, -1,  0, -1]
[0, m, 0,   0, 0, 0, 0,   0,    0,  0, -1,  0]
[0, 0, 1, -r0, 0, 0, 0,   0, -c_d,  0,  0,  0]
[0, 0, 0,   0, 0, 0, 0,   0,    0,  1,  0,  0]
[0, 0, 0,   0, 0, 0, 0,   0,    0,  0,  1,  0]
[0, 0, 0,   0, 0, 0, 0, A*k, -A*k,  0,  0,  1]
 
</pre>
<p>
<b>Calculate symbolic jacobian matrix using a mix of numeric variable values and symbolic variables:</b>
</p>
<p>Also symbolic and numeric values can be mixed</p>
<pre class="codeinput">dx = zeros(sys.n, 1);
x = sym(<span class="string">'x'</span>,[sys.n,1]);
u = [sym(<span class="string">"u1"</span>); 0; 0; 0];
y = sym(<span class="string">'y'</span>,[sys.p,1]);

J = sys.jacobian(dx, x, u, y);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))
</pre>
<pre class="codeoutput">[m, 0,  0,             0,              0, -1,  0, -1,  0,       0,      0,   0]
[0, m,  0,             0,              0,  0, -1,  0,  0,       0,      0,   0]
[0, 0,  1, - r0 - c_v*y1, - c_d - c_v*x2,  0,  0,  0,  0,       0,      0,   0]
[0, 0, u1,             0,              0,  1,  0,  0, x1, -c_d*u1, -r0*u1,   0]
[0, 0,  0,            u1,              0,  0,  1,  0, x2,       0,    -u1,   0]
[0, 0,  0,             0,           -A*k,  0,  0,  1,  0,       0,      0, A*k]
 
</pre>
<p>
<b>Calculate jacobian matrix for numeric model parameters and variables:</b>
</p>
<p>Using the replaceSymbolicParameters() functions, the symbolic parameters of the model can be replaced by according numeric values</p>
<pre class="codeinput">symParameters = [sym(<span class="string">"m"</span>), sym(<span class="string">"c_d"</span>), sym(<span class="string">"c_v"</span>), sym(<span class="string">"r0"</span>), sym(<span class="string">"A"</span>), sym(<span class="string">"k"</span>)];
numParameters = [9.03*11.33*3.4*1.225, 1006, 1860, 2501*10^3, 2*(9.03+11.33)*3.4 + 9.03*11.33, 3];
sys = sys.replaceSymbolicParameters(symParameters, numParameters);

dx = zeros(sys.n, 1);
x = zeros(sys.n, 1);
u = zeros(sys.m, 1);
y = zeros(sys.p, 1);

J = sys.jacobian(dx, x, u, y);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))
</pre>
<pre class="codeoutput">   1.0e+06 *

  Columns 1 through 7

    0.0004         0         0         0         0         0         0
         0    0.0004         0         0         0         0         0
         0         0    0.0000   -2.5010         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0

  Columns 8 through 12

         0         0   -0.0000         0   -0.0000
         0         0         0   -0.0000         0
         0   -0.0010         0         0         0
         0         0    0.0000         0         0
         0         0         0    0.0000         0
    0.0007   -0.0007         0         0    0.0000

</pre>
<p>Using numeric variables as well as numeric parameters facilitates the fastest calculation of the jacobian.</p>
<h2 id="12">References</h2>
<p>[1] C. Kaufmann, D. Cresp&iacute;, G. Lichtenberg, Georg Pangalos, and Carlos Cateriano Y&aacute;&ntilde;ez, "Efficient Linearization of Explicit Multilinear Systems using Normalized Decomposed Tensors,&rdquo; IFAC-PapersOnLine, vol. 56, no. 2, pp. 7312&ndash;7317, Jan. 2023, doi: <a href="https://doi.org/10.1016/j.ifacol.2023.10.344">https://doi.org/10.1016/j.ifacol.2023.10.344</a>.</p>
<h2 id="13">See also</h2>
<p>
<a href="dmssDoc.html">dmss</a>, <a href="dmsimDoc.html">dmsim</a>, <a href="sym2dmssDoc.html">sym2dmss</a>, <a href="incidenceMatrixDoc.html">incidenceMatrix</a> <a href="hyCPN1Doc.html">hyCPN1</a>, <a href="replaceSymbolicParametersDoc.html">replaceSymbolicParameters</a>
</p>
<p>Author(s): Torben Warnecke</p>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% jacobian
% Calculate jacobian matrix of a dmss model.
%% Syntax
% J = jacobian(sys) Calculate jacobian matrix with default symbolic variables [xpi, xi, ui, yi].
%
% J = jacobian(sys, xp, x, u, y) Calculate jacobian matrix for given
% variable values (numeric or symbolic).
%
% J = jacobian(sys, xp, x, u, y, z) Calculate jacobian matrix for given
% variable values (numeric or symbolic) for hybrid dmss model (Experimental).
%% Description
% jacobian(sys) calculates the jacobian matrix of an implicit multilinear time-invariant (iMTI) model stored as dmss object based of the decomposed
% parameter tensor sys.H (based of its structure matrix sys.H.F and parameter matrix sys.H.phi) with numeric or smybolic parameters, using similar principles as in [1] for explicit mutlilinear time invariant (eMTI) models.
%% Examples
% The following equations describe a simple HVAC system
Eq =                            ["m*xp1 - y4 - y2 = 0";...
                                      "m*xp2 - y3 = 0";...
                 "x1 - c_d*y1 - r0*x2 - c_v*x2*y1 = 0";...
"y2 + u1*x1 - c_d*u1*u2 - r0*u1*u3 - c_v*u1*u2*u3 = 0";...
                              "y3 - u1*u3 + u1*x2 = 0";...
                            "y4 + A*k*u4 - A*k*y1 = 0"];
%%
% which can be converted into a continuous-time dmss model by
sys = sym2dmss(Eq, 0);
%%
% and serves as an example system.
%
% *Calculate symbolic jacobian matrix:*
%
% The symbolic jacobian matrix can be calculated simply by
J = sys.jacobian()
%%
% For viewing the entries of the jacobian matrix the entries of the struct
% can be accessed.
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))
%%
% where the rows correspond to the six equations and the columns to the
% variables (2 state derivatives, 2 states, 4 inputs, 4 algebraic
% variables).
%
% *Calculate symbolic jacobian matrix using nondefault variable symbols:*
%
% Nondefault variable symbols can be used by using the additional inputs of
% jacobian()
dx = sym('dx',[sys.n,1]);
x = sym('x',[sys.n,1]);
in = sym('in',[sys.m,1]);
out = sym('out', [sys.p,1]);

J = sys.jacobian(dx, x, in, out);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))

%%
% *Calculate jacobian matrix using numeric variable values:*
%
% For calculating the jacobian matrix for certain numeric variable values,
% they can be simply entered as the inputs of jacobian()
dx = zeros(sys.n, 1);
x = zeros(sys.n, 1);
u = zeros(sys.m, 1);
y = zeros(sys.p, 1);

J = sys.jacobian(dx, x, u, y);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))

%%
% *Calculate symbolic jacobian matrix using a mix of numeric variable values and symbolic variables:*
%
% Also symbolic and numeric values can be mixed
dx = zeros(sys.n, 1);
x = sym('x',[sys.n,1]);
u = [sym("u1"); 0; 0; 0];
y = sym('y',[sys.p,1]);

J = sys.jacobian(dx, x, u, y);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))

%%
% *Calculate jacobian matrix for numeric model parameters and variables:*
%
% Using the replaceSymbolicParameters() functions, the symbolic parameters
% of the model can be replaced by according numeric values
symParameters = [sym("m"), sym("c_d"), sym("c_v"), sym("r0"), sym("A"), sym("k")];
numParameters = [9.03*11.33*3.4*1.225, 1006, 1860, 2501*10^3, 2*(9.03+11.33)*3.4 + 9.03*11.33, 3];
sys = sys.replaceSymbolicParameters(symParameters, numParameters);

dx = zeros(sys.n, 1);
x = zeros(sys.n, 1);
u = zeros(sys.m, 1);
y = zeros(sys.p, 1);

J = sys.jacobian(dx, x, u, y);
disp(full([J.equality.stateDerivative, J.equality.state, J.equality.input, J.equality.algebraic]))

%%
% Using numeric variables as well as numeric parameters facilitates the
% fastest calculation of the jacobian.

%% References
% [1] C. Kaufmann, D. Crespí, G. Lichtenberg, Georg Pangalos, and Carlos Cateriano Yáñez, "Efficient Linearization of Explicit Multilinear Systems using Normalized Decomposed Tensors,” IFAC-PapersOnLine, vol. 56, no. 2, pp. 7312–7317, Jan. 2023, doi: https://doi.org/10.1016/j.ifacol.2023.10.344.
%% See also
% <dmssDoc.html dmss>,
% <dmsimDoc.html dmsim>,
% <sym2dmssDoc.html sym2dmss>,
% <incidenceMatrixDoc.html incidenceMatrix>
% <hyCPN1Doc.html hyCPN1>,
% <replaceSymbolicParametersDoc.html replaceSymbolicParameters>
%
%
% Author(s): Torben Warnecke

##### SOURCE END #####
-->
</body>
</html>
