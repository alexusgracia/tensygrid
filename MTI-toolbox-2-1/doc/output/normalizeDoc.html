<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>normalize</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-06-24">
<meta name="DC.source" content="normalizeDoc.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>normalize</h1>
<!--introduction-->
<p>Linear coordinate transformation of the variables of a dmss model.</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Syntax</a>
</li>
<li>
<a href="#2">Examples</a>
</li>
<li>
<a href="#8">References</a>
</li>
<li>
<a href="#9">See also</a>
</li>
</ul>
</div>
<h2 id="1">Syntax</h2>
<p>sys = normalize(sys,stateCurrentRange, stateTargetRange, inputCurrentRange, inputTargetRange, algebraicCurrentRange, algebraicTargetRange) Linear coordinate transformation of the variables (states x, inputs u, algebraic variables y) of a dmss model, based of current and target ranges, parse as matrices where the first column is the lower limit and the second column is the upper limit. The rows correspond to the different variables xi, ui and yi.</p>
<p>[sys, stateOffset, stateSlope, inputOffset, inputSlope, algebraicOffset, algebraicSlope] = normalize(sys,stateCurrentRange, stateTargetRange, inputCurrentRange, inputTargetRange, algebraicCurrentRange, algebraicTargetRange) Additional outputs with information of the offsets and slopes of the linear coordinate transformation.</p>
<h2 id="2">Examples</h2>
<p>The following set of equations describe a simple HVAC system</p>
<pre class="codeinput">Eq = [<span class="string">"9.03*11.33*3.4*1.225*xp1 - y4 - y2 = 0"</span>;<span class="keyword">...</span>
      <span class="string">"9.03*11.33*3.4*1.225*xp2 - y3 = 0"</span>;<span class="keyword">...</span>
      <span class="string">"x1 - 1006*y1 - 2501*10^3*x2 - 1860*x2*y1 = 0"</span>;<span class="keyword">...</span>
      <span class="string">"y2 + u1*x1 - 1006*u1*u2 - 2501*10^3*u1*u3 - 1860*u1*u2*u3 = 0"</span>;<span class="keyword">...</span>
      <span class="string">"y3 - u1*u3 + u1*x2 = 0"</span>;<span class="keyword">...</span>
      <span class="string">"y4 + (2*(9.03+11.33)*3.4 + 9.03*11.33*3)*u4 - (2*(9.03+11.33)*3.4 + 9.03*11.33*3)*y1 = 0"</span>];
</pre>
<p>which can be converted into a continuous-time dmss model by</p>
<pre class="codeinput">sys = sym2dmss(Eq, 0)
</pre>
<pre class="codeoutput">Reduced by 5 column(s) and 0 equation(s) with trivial Reduction due to duplications.

sys = 

  dmss with properties:

                H: [1&times;1 hyCPN1]
                n: 2
                m: 4
                p: 4
      outputIndex: [1&times;1 struct]
              nEq: 6
        stateName: [0&times;0 string]
        stateUnit: [0&times;0 string]
    algebraicName: [0&times;0 string]
    algebraicUnit: [0&times;0 string]
        inputName: [0&times;0 string]
        inputUnit: [0&times;0 string]
               ts: 0

</pre>
<p>which serves as an example system.</p>
<p>The model can variables can be scaled e.g. to values between -1 and 1. Therefore the current and target ranges of the different variables need to be defined. If a variable shouldn't be scaled the current and target ranges must be the same. Also it is important that lower and upper limit are not equal, e.g. [0, 0]. If a whole variable type shouldn't be scaled, in this example the inputs, the matrices can be left empty.</p>
<pre class="codeinput">stateCurrentRange = [0, 1e5; 0, 0.025];
stateTargetRange = [-1 1; -1 1];

algebraicCurrentRange = [-20, 50; -10e6, 10e6; -1, 1; -1e5, 1e5];
algebraicTargetRange = [-1 1; -1 1; -1 1; -1 1];

inputCurrentRange = [];
inputTargetRange = [];

[sysNorm, stateOffset, stateSlope, inputOffset, inputSlope, algebraicOffset, algebraicSlope] = normalize(sys,stateCurrentRange, stateTargetRange, inputCurrentRange, inputTargetRange, algebraicCurrentRange, algebraicTargetRange);
</pre>
<p>Now the system can be simulated (keeping the slopes and offsets in mind for the initial states)</p>
<pre class="codeinput">t = [0, 60];
x0 = ([75000; 0.018] - stateOffset')./stateSlope';
u = [150/1.225, 18, 0.01, 32] .* ones(length(t),1);
rng(100)
u = u .* (0.9 + rand(size(u))/10);

simout = dmsim(sysNorm, x0, t, u);
</pre>
<pre class="codeoutput">Seperation in 1 subset(s) with 6 subproblem(s), from which 6 are explicit solvable.</pre>
<p>The results can be plotted by accessing the properties of the simulation object</p>
<pre class="codeinput">figure()
plot(simout.tsim, simout.x)
hold <span class="string">on</span>
plot(simout.tsim, simout.y)
grid <span class="string">on</span>
hold <span class="string">off</span>
</pre>
<img vspace="5" hspace="5" src="normalizeDoc_01.png" alt=""> <p>The signals can be scaled back by simply multiplying with the slope and adding the offset.</p>
<pre class="codeinput">x = simout.x.*stateSlope+stateOffset;
y = simout.y.*algebraicSlope+algebraicOffset;

figure()
plot(simout.tsim, x)
hold <span class="string">on</span>
plot(simout.tsim, y)
grid <span class="string">on</span>
hold <span class="string">off</span>
</pre>
<img vspace="5" hspace="5" src="normalizeDoc_02.png" alt=""> <h2 id="8">References</h2>
<h2 id="9">See also</h2>
<p>
<a href="dmssDoc.html">dmss</a>, <a href="dmsimDoc.html">dmsim</a>, <a href="sym2dmssDoc.html">sym2dmss</a>, <a href="replaceSymbolicParametersDoc.html">replaceSymbolicParameters</a>
</p>
<p>Author(s): Torben Warnecke</p>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% normalize
% Linear coordinate transformation of the variables of a dmss
% model.
%% Syntax
% sys = normalize(sys,stateCurrentRange, stateTargetRange,
% inputCurrentRange, inputTargetRange, algebraicCurrentRange,
% algebraicTargetRange) Linear coordinate transformation of the variables (states x, inputs u, algebraic variables y) of a
% dmss model, based of current and target ranges, parse as matrices where
% the first column is the lower limit and the second column is the upper
% limit. The rows correspond to the different variables xi, ui and yi.
%
% [sys, stateOffset, stateSlope, inputOffset, inputSlope, algebraicOffset, algebraicSlope] = normalize(sys,stateCurrentRange, stateTargetRange, inputCurrentRange, inputTargetRange, algebraicCurrentRange, algebraicTargetRange)
% Additional outputs with information of the offsets and slopes of the linear coordinate
% transformation.
%% Examples
% The following set of equations describe a simple HVAC system
Eq = ["9.03*11.33*3.4*1.225*xp1 - y4 - y2 = 0";...
      "9.03*11.33*3.4*1.225*xp2 - y3 = 0";...
      "x1 - 1006*y1 - 2501*10^3*x2 - 1860*x2*y1 = 0";...
      "y2 + u1*x1 - 1006*u1*u2 - 2501*10^3*u1*u3 - 1860*u1*u2*u3 = 0";...
      "y3 - u1*u3 + u1*x2 = 0";...
      "y4 + (2*(9.03+11.33)*3.4 + 9.03*11.33*3)*u4 - (2*(9.03+11.33)*3.4 + 9.03*11.33*3)*y1 = 0"];
%%
% which can be converted into a continuous-time dmss model by
sys = sym2dmss(Eq, 0)
%%
% which serves as an example system.
%
% The model can variables can be scaled e.g. to values between -1 and 1.
% Therefore the current and target ranges of the different variables need
% to be defined. If a variable shouldn't be scaled the current and target
% ranges must be the same. Also it is important that lower and upper limit
% are not equal, e.g. [0, 0].
% If a whole variable type shouldn't be scaled, in this example the inputs,
% the matrices can be left empty.

stateCurrentRange = [0, 1e5; 0, 0.025];
stateTargetRange = [-1 1; -1 1];

algebraicCurrentRange = [-20, 50; -10e6, 10e6; -1, 1; -1e5, 1e5];
algebraicTargetRange = [-1 1; -1 1; -1 1; -1 1];

inputCurrentRange = [];
inputTargetRange = [];

[sysNorm, stateOffset, stateSlope, inputOffset, inputSlope, algebraicOffset, algebraicSlope] = normalize(sys,stateCurrentRange, stateTargetRange, inputCurrentRange, inputTargetRange, algebraicCurrentRange, algebraicTargetRange);
%%
% Now the system can be simulated (keeping the slopes and offsets in mind
% for the initial states)
t = [0, 60];
x0 = ([75000; 0.018] - stateOffset')./stateSlope';
u = [150/1.225, 18, 0.01, 32] .* ones(length(t),1);
rng(100)
u = u .* (0.9 + rand(size(u))/10);

simout = dmsim(sysNorm, x0, t, u);
%%
% The results can be plotted by accessing the properties of the simulation
% object
figure()
plot(simout.tsim, simout.x)
hold on
plot(simout.tsim, simout.y)
grid on
hold off
%%
% The signals can be scaled back by simply multiplying with the slope and
% adding the offset.
x = simout.x.*stateSlope+stateOffset;
y = simout.y.*algebraicSlope+algebraicOffset;

figure()
plot(simout.tsim, x)
hold on
plot(simout.tsim, y)
grid on
hold off
%% References

%% See also
% <dmssDoc.html dmss>,
% <dmsimDoc.html dmsim>,
% <sym2dmssDoc.html sym2dmss>,
% <replaceSymbolicParametersDoc.html replaceSymbolicParameters>
%
%
% Author(s): Torben Warnecke
##### SOURCE END #####
-->
</body>
</html>
