classdef norm1CPN < cpnTens

    properties (Dependent, SetAccess = private)
        equationCount int64
        inputCount int64
    end
    methods
            % norm1CPN Construct a norm1CPN object
            %   tens = norm1CPN() Constructs an empty norm1CPN object.
            %
            %   tens = norm1CPN(U,phi) construct a norm2
            %
            %   tens = norm1CPN(ktensor) Constructs a norm1CPN object in
            %   from a parameter-tensor in ktensor (from the Tensor Toolbox) format 
            %

        function obj = norm1CPN(varargin)
            if(nargin == 0)
                obj.U = double.empty();
                obj.phi = double.empty();
            elseif(nargin == 1)
                if (isa(varargin{1}, 'double') && isequal(size(varargin{1}), [2,2]))
                    warning('norm1CPN:matrix2x2Warning', 'Input array is treated as 2x2-Matrix, if it should be treated as tensor, use the fullTens-class: norm1CPN(fullTens(A))')
                end

                if isa(varargin{1},'ktensor')
                    [U,phi] = obj.ktensor2norm1CPN(varargin{1});
                elseif (isa(varargin{1}, 'double') && ndims(varargin{1}) <= 2) % checks if input is a matrix or vector double array
                    [U,phi] = cpnTens.mat2Cpn(varargin{1});
                elseif (isa(varargin{1}, 'double') && ndims(varargin{1}) >2) % checks if input is a double tensor (matlab native)
                    [U,phi] = cpnTens.fulltens2Cpn(varargin{1});
                elseif isa(varargin{1}, 'fullTens') % checks if input is a fullTens-object (for the special case of 2x2x1 Tensors)
                    [U,phi] = cpnTens.fulltens2Cpn(varargin{1}.Tens);
                end


                obj.U = U;
                obj.phi = phi;

                setXUfun(obj);
            elseif(nargin == 2)
                                
                obj.U = varargin{1};
                obj.phi = varargin{2};

                setXUfun(obj);
                % TODO size check
                
            else
                error("Error initializing norm1 Object, invalid number of inputs. Expected parameters U and phi ")
            end

        end

        function result = processXU(sys,xu)
            result = sys.processXUfun(sys,xu);
        end

        function equationCount = get.equationCount(obj)
            equationCount = size(obj.phi,1);
        end

        function inputCount = get.inputCount(obj)
            inputCount = size(obj.U,1) - obj.equationCount;
        end

    end
    methods (Static, Access = public) 
            [U,phi] = ktensor2norm1CPN(T)
    end

end

function setXUfun(obj)
    % This defines a lambda function as a property of the norm1CPN object,
    % circumventing two different subclasses for bool and double
    % calculations. This will probably be obsolete as soon as we progress
    % on sparse/nonsparse differentiation and also when we want to be able
    % to handle hybrid systems
    if(islogical(obj.U))
        obj.processXUfun = @(sys,xu) sys.phi*accumarray(sys.ColInd,xu(sys.RowInd),[sys.rowsU 1],@prod,1);
    else
        obj.processXUfun = @(sys,xu) sys.phi*accumarray(sys.ColInd,1+sys.DataVec.*(xu(sys.RowInd)+sys.SignVec),[sys.rowsU 1],@prod,1);
    end
end